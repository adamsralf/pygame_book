% !TeX spellcheck = en_US
\newpage
\section{Bubbles}\index{Bubbles}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this chapter, the game \emph{Bubbles} is discussed as an example. We will develop this game step by step in a systematic way. I will assume that the techniques introduced in \kapref{secGoals} are already familiar. I will deliberately omit docstring comments in the source code, since everything is explained in the text and the listings would otherwise become unnecessarily long. In the final version, however, these comments are included.

\begin{hintbox}[Thank you]
	I would like to point out right away that the idea for the game did not come from me. A student once presented it as a mobile version at an \Gls{ita} fair. Unfortunately, I can no longer remember the student’s name, but I would like to take this opportunity to say a sincere \emph{thank you}.
\end{hintbox}

The game can be extended almost without limits: bubble popping animations, high score lists, and much more. But as is so often the case, the better is the enemy of the good. I hope you enjoy studying this example.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\Reqref{reqStandard}: Standards}
\begin{diskbox}
	\url{https://github.com/adamsralf/pygame_book/tree/main/src/02%20Examples/02%20Bubbles/v01}
\end{diskbox}

\br{Standard functionality}{reqStandard}
\begin{enumerate}
	\item The window has an appropriate size.\label{reqStandardGröße}
	\item The background is either a suitable bitmap or a solid color.\label{reqStandardHintergrund}
	\item The game can be exited using \keys{\esc} or by clicking the red “X”.\label{reqStandardBeenden}
	\item All bitmaps are converted and scaled appropriately after loading.\label{reqStandardSprite}
	\item All bitmaps -- except for the background -- are transparent.\label{reqStandardTransparenz}
	\item All bitmaps are stored in \texttt{pygame.sprite.Group} or \texttt{py\-game\-.sprite\-.Group\-Single} objects.\label{reqStandardGruppe}
	\item The game has a frame-rate-independent execution speed.\label{reqStandardFps}
\end{enumerate}
\er

\Reqref[vref]{reqStandard} does not only define specific requirements, but also general ones. For this reason, it will appear again in later implementations.

At this point, the preamble is presented once. I assume that you have sufficient Python knowledge to extend it as needed. The static configuration values of the game are stored, as usual, in the separate \texttt{config.py} file.

It is required that the window has an appropriate size. With $\SI{1220}{px} \times \SI{1002}{px}$, the window is large enough to distribute the bubbles, yet small enough to allow quick mouse movement. Everything else has already been discussed in detail in previous chapters (e.g.\ \texttt{FPS}, \texttt{DELTATIME}, or \texttt{PATH}) and will therefore not be explained further here.

\myebild{aquarium01}{0.15}{Bubbles: background image}{picAquarium01}

\lstsource{SRC/02 Examples/02 Bubbles/v01/config.py}{1}{99}{python}{Bubbles (\reqref{reqStandard}.\ref{reqStandardGröße}) -- \texttt{config.py}
}{srcBubbles01a}

The \texttt{Background} class is a subclass of \texttt{Sprite}. It is only loaded and scaled to the appropriate size. Since the background never changes, there is no need to implement an \texttt{update()} method. Creating a dedicated subclass for this is somewhat like using a sledgehammer to crack a nut. We could just as well have implemented it directly as a \texttt{Sprite} object. I chose this approach purely for the sake of clarity. The background image can be seen in \abbref[vref]{picAquarium01}.

%\newpage
\lstsource{SRC/02 Examples/02 Bubbles/v01/bubbles.py}{7}{13}{python}{Bubbles (\reqref{reqStandard}.\ref{reqStandardHintergrund}) -- \texttt{Background
}}{srcBubbles01c}

In the \texttt{Game} class, the usual Pygame suspects are initialized or created in \texttt{\_\_init\_\_()}: \texttt{init()}\myindex{pyg}{\texttt{init()}}, \texttt{Window()}\myindex{pyg}{\texttt{Window}}, and \texttt{clock()}\myindex{pyg}{\texttt{time}!\texttt{Clock}}. The flag \texttt{running} for the main game loop is also initialized. The methods \texttt{run()}, \texttt{watch\_for\_events()}, \texttt{up\-date()}, and \texttt{draw()} contain only basic functionality and therefore do not need to be explained further at this point.

\lstsource{SRC/02 Examples/02 Bubbles/v01/bubbles.py}{16}{52}{python}{Bubbles (\reqref{reqStandard}) -- \texttt{Game}}{srcBubbles01d}  

However, these methods already define the overall flow of the game. All further properties of the game are merely extensions of this flow and no longer change it. Finally, the call is made (see \srcref[vref]{srcBubbles01s}). With this, all subitems of \reqref[vref]{reqStandard} that apply here are fulfilled.

\lstsource{SRC/02 Examples/02 Bubbles/v01/bubbles.py}{55}{999}{python}{Bubbles (\reqref{reqStandard}) -- invocation}{srcBubbles01s}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\Reqref{reqBlasenErscheinen}: Bubbles appear}
\begin{diskbox}
	\url{https://github.com/adamsralf/pygame_book/tree/main/src/02%20Examples/02%20Bubbles/v02}
\end{diskbox}


\br{Bubbles appear}{reqBlasenErscheinen}
\begin{enumerate}
	\item A bubble appears at a random position.\label{reqBlasenErscheinenZufall}
	\item At the beginning, this happens every half second.\label{reqBlasenErscheinenIntervall}
	\item It has an initial radius of \SI{15}{px}.\label{reqBlasenErscheinenRadius}
	\item It keeps a minimum distance of \SI{10}{px} from the edges.\label{reqBlasenErscheinenAbstand}
	\item It keeps a minimum distance of \SI{10}{px} from all other bubbles.\label{reqBlasenErscheinenMindestabstand}
\end{enumerate}
\er


\begin{wrapfigure}[6]{r}{3.1cm}%
	\begin{center}%
		\vspace{-1cm}%
		\myfigure{blase1.png}{0.05}{Bubble}{picBlase1}%
	\end{center}%
\end{wrapfigure}%
For the bubble, we use the already transparent graphic from \abbref{picBlase1}. The random position still needs to be restricted. The aquarium does not fill the entire screen (see \abbref[vref]{picAquarium01}); instead, it sits inside something like a TV frame. So we have to define a playing area (\emph{playground}). The bubbles should only appear inside this area.

The playing area is a rectangle\index{rectangle}\index{self.rect} with an offset from the left and top edges of the screen -- \texttt{left}\myindex{pyg}{\texttt{Rect}!\texttt{left}} and \texttt{top}\myindex{pyg}{\texttt{Rect}!\texttt{top}} -- and a width (\texttt{width}\myindex{pyg}{\texttt{Rect}!\texttt{width}}) and height (\texttt{height}\myindex{pyg}{\texttt{Rect}!\texttt{height}}). The corresponding values are defined in \zeiref{srcBubble0203}. The distance to the border of the playing area and the minimum distance between bubbles are defined in \zeiref{srcBubble0202} as \SI{10}{px}, in accordance with \reqref{reqBlasenErscheinen}.\ref{reqBlasenErscheinenAbstand}. The initial radius\index{self.radius} -- and therefore the minimum radius -- is set to \SI{15}{px} in \zeiref{srcBubble0201} because of \reqref{reqBlasenErscheinen}.\ref{reqBlasenErscheinenRadius}. While playing, I noticed that smaller initial radii are simply too hard to see.

\lstsource{SRC/02 Examples/02 Bubbles/v02/config.py}{14}{16}{python}{Bubbles (\reqref{reqBlasenErscheinen}) -- additions in \texttt{config.py}}{srcBubbles02a}

The \texttt{Timer} class is exactly the one described above in \kapref[vref]{secZeitsteuerung}\index{Timer}; everything is explained there.

\lstsource{SRC/02 Examples/02 Bubbles/v02/bubbles.py}{9}{21}{python}{Bubbles (\reqref{reqBlasenErscheinen}) -- \texttt{Timer}}{srcBubbles02b}  

Let us now take a look at the \texttt{Bubble} class. The constructor is self-explanatory; it only handles the usual suspects: \texttt{image}, \texttt{rect}, and \texttt{radius}. The \texttt{update()} method is currently empty, since no changes are required yet. However, the \texttt{randompos()} method is needed because of \reqref{reqBlasenErscheinen}.\ref{reqBlasenErscheinenZufall}. It calculates a new bubble center and assigns it to \texttt{rect}. If necessary, this method must be repeated until a free area is found (see \reqref{reqBlasenErscheinen}.\ref{reqBlasenErscheinenAbstand} and~\reqref{reqBlasenErscheinen}.\ref{reqBlasenErscheinenMindestabstand}).

\lstsource{SRC/02 Examples/02 Bubbles/v02/bubbles.py}{33}{49}{python}{Bubbles (\reqref{reqBlasenErscheinen}) -- \texttt{Bubble}}{srcBubbles02c}  

The \texttt{Game} class now has to be extended accordingly. In \zeiref{srcBubble0204}, the \texttt{Background} object is created. \zeiref{srcBubble0205} creates a \texttt{Timer} object with an interval of \SI{500}{ms}, where no bubbles are generated during the first interval (see \reqref{reqBlasenErscheinen}.\ref{reqBlasenErscheinenIntervall}).

\lstsource{SRC/02 Examples/02 Bubbles/v02/bubbles.py}{52}{61}{python}{Bubbles (\reqref{reqBlasenErscheinen}) -- Constructor of \texttt{Game}}{srcBubbles02d}  

In the \texttt{draw()} method, only the \texttt{draw()} methods of the sprite groups are called. The \texttt{update()} method has also been adjusted; it now calls the \texttt{spawn\_bubble()} method and thus delegates the task of creating new bubbles.

\lstsource{SRC/02 Examples/02 Bubbles/v02/bubbles.py}{71}{77}{python}{Bubbles (\reqref{reqBlasenErscheinen}) -- \texttt{draw()} and \texttt{update()} of \texttt{Game}}{srcBubbles02e}  

The basic idea behind \texttt{spawn\_bubble()} is to keep guessing a position for a new bubble until a free area is found.
\begin{warningbox}[Avoid endloss loop]
	To avoid ending up in an \gls{endlosschleife}, the number of attempts is limited to~100. If no free area is found, the bubble is not added to the sprite group -- it is simply discarded.
\end{warningbox}

For this purpose, the radius is temporarily increased (\zeiref{srcBubble0207}) and then reduced back to its original value after the collision check (\zeiref{srcBubble0208}). 

This is an example showing that a method reference is passed to \texttt{pygame.sprite\-.sprite\-collide()}\myindex{pyg}{\texttt{sprite}!\texttt{spritecollide()}}\randnotiz{sprite\-collide()} -- in this case \texttt{pygame.sprite.collide\_circle()}\myindex{pyg}{\texttt{sprite}!\texttt{collide\_circle()}}\randnotiz{collide\_\-circle()} -- and that the usual rectangle-based collision check is therefore not used.

\lstsource{SRC/02 Examples/02 Bubbles/v02/bubbles.py}{79}{89}{python}{Bubbles (\reqref{reqBlasenErscheinen}) -- \texttt{spawn\_bubble()} of \texttt{Game}}{srcBubbles02f}  

The result can be seen in \abbref[vref]{picAquarium02}. The bubbles are evenly distributed across the playing area, and the required minimum distance to the edges and between the bubbles is maintained.

\myebild{aquarium02}{0.32}{Bubbles: the bubbles have a minimum distance at the start}{picAquarium02}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\Reqref{reqBlasenanzahl}: Number of bubbles}
\begin{diskbox}
	\url{https://github.com/adamsralf/pygame_book/tree/main/src/02%20Examples/02%20Bubbles/v03}
\end{diskbox}

\br{Number of bubbles}{reqBlasenanzahl}
	The maximum number of bubbles shall depend on the size of the playing area.
\er

I want to define the maximum number in the \texttt{Game} class. Based on the available area, an upper limit is calculated:

\lstsource{SRC/02 Examples/02 Bubbles/v03/config.py}{17}{17}{python}{Bubbles (\reqref{reqBlasenanzahl}) -- additions in \texttt{config.py}}{srcBubbles03a}  

This upper limit from \zeiref{srcBubble0301} is checked in \zeiref{srcBubble0306}. A new bubble is only created if the maximum number has not yet been reached.

\lstsource{SRC/02 Examples/02 Bubbles/v03/bubbles.py}{79}{90}{python}{Bubbles (\reqref{reqBlasenanzahl}) -- additions in \texttt{Game.spawn\_bubbles()}}{srcBubbles03b}  

The rest of the program remains unchanged.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\Reqref{reqBlasenWachstum}: Bubble growth}
\begin{diskbox}
	\url{https://github.com/adamsralf/pygame_book/tree/main/src/02%20Examples/02%20Bubbles/v04}
\end{diskbox}

\br{Bubble growth}{reqBlasenWachstum}
\begin{enumerate}
	\item Bubbles of different sizes are managed in a container.\label{reqBlasenWachstumContainer}
	
	\item The maximum radius of a bubble is \SI{240}{px}.\label{reqBlasenWachstumMax}
\end{enumerate}
\er

The purpose of \reqref{reqBlasenWachstum}.\ref{reqBlasenWachstumContainer} is to save computing time. During the game, bubbles repeatedly start with a certain radius and then grow. Scaling the bitmap to the required size every single time would waste processing power -- after all, the same bubble appears multiple times with identical radii. For this reason, it makes sense to scale the bubble once to all possible radii and store the results in a dictionary. The key used is the respective radius (see \zeiref{srcBubble0403}).\myindex{pyg}{\texttt{transform}!\texttt{scale()}}\randnotiz{scale()}

The \texttt{get()} method then returns the appropriately scaled and ready-to-use image for a given radius. Before that, lines~\ref{srcBubble0404} and~\ref{srcBubble0405} check whether the radius lies within the valid range. If the radius is too large, the maximum value is used; if it is too small, the minimum value is applied instead.

\lstsource{SRC/02 Examples/02 Bubbles/v04/bubbles.py}{33}{42}{python}{Bubbles (\reqref{reqBlasenWachstum}.\ref{reqBlasenWachstumContainer}) -- \texttt{BubbleContainer}}{srcBubbles04a}  

So far, only a start value -- and thus a lower bound -- for the bubble radius has been defined in \texttt{Game}. This definition is now extended in \zeiref{srcBubble0400} in accordance with \reqref{reqBlasenWachstum}.\ref{reqBlasenWachstumMax} by adding a maximum radius.

\lstsource{SRC/02 Examples/02 Bubbles/v04/config.py}{14}{14}{python}{Bubbles (\reqref{reqBlasenWachstum}.\ref{reqBlasenWachstumMax}) -- extension of \texttt{config.py}}{srcBubbles04b}

The \texttt{BubbleContainer} is passed to the constructor of \texttt{Bubble}, allowing this class to retrieve images from it. A direct example of this can be found in \zeiref{srcBubble0407}. The \texttt{image} attribute is set according to the current \texttt{radius}.

The \texttt{update()} method is no longer empty. Its main purpose is to make the bubble grow. To achieve this, the radius is continuously increased, which results in increasingly larger images being loaded from the \texttt{BubbleContainer} and displayed (\zeiref{srcBubble0412}). The new radius is calculated in \zeiref{srcBubble0410}. In the same line, this value is compared with the maximum radius from \texttt{config.py}, and the minimum of the two is selected. This logic prevents the radius from becoming too large.

\begin{hintbox}[Center-based scaling]
	But what is the purpose of lines~\ref{srcBubble0411} and~\ref{srcBubble0413}\index{center-based scaling}? The reference point of an image in a sprite is its top-left corner. If the bubble grows, it would therefore expand to the right and downward; the left and top edges would remain fixed, which looks awkward. To avoid this, we store the old center point, load the new image, create the corresponding \texttt{Rect} object, and then move it back to the old center. This way, the bubble visually grows outward from its center in all directions.
\end{hintbox}

\lstsource{SRC/02 Examples/02 Bubbles/v04/bubbles.py}{45}{70}{python}{Bubbles (\reqref{reqBlasenWachstum}) -- extension of \texttt{Bubble}}{srcBubbles04c}  

The \texttt{update()} method in \texttt{Game} only needs to be extended by calling all \texttt{update()} methods of the bubbles. This can be done very conveniently using the sprite group mechanism. Just like with \texttt{draw()}, \texttt{update()} can be called for the entire group in a single step (see \zeiref{srcBubble0414}).

\lstsource{SRC/02 Examples/02 Bubbles/v04/bubbles.py}{98}{100}{python}{Bubbles (\reqref{reqBlasenWachstum}) -- extension of \texttt{Game.update()}}{srcBubbles04d}  

Create the BubbleContainer

\lstsource{SRC/02 Examples/02 Bubbles/v04/bubbles.py}{79}{81}{python}{Bubbles (\reqref{reqBlasenWachstum}) -- extension of the constructor of \texttt{Game}}{srcBubbles04f}  

And in the \texttt{spawn\_bubble()} method, the constructor call of \texttt{Bubble} is extended by passing the \texttt{BubbleContainer}.

\lstsource{SRC/02 Examples/02 Bubbles/v04/bubbles.py}{102}{106}{python}{Bubbles (\reqref{reqBlasenWachstum}) -- extension of \texttt{Game.spawn\_bubble()}}{srcBubbles04e}  

The bubbles now grow outward from their center. The result might then look like the one shown in \abbref[vref]{picAquarium03}.

\myebild{aquarium03}{0.19}{Bubbles -- the bubbles have grown and merged}{picAquarium03}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{\Reqref{reqMauscursor}: Mouse cursor}
\begin{diskbox}
	\url{https://github.com/adamsralf/pygame_book/tree/main/src/02%20Examples/02%20Bubbles/v05}
\end{diskbox}

\br{Mouse cursor}{reqMauscursor}
	If the mouse is inside a bubble, its appearance should change.
\er

This requirement is intended to provide visual feedback to the player. It allows them to recognize more quickly whether they have already reached a bubble. Pygame itself does not provide a method or function to test whether a point lies inside a circle. However, \abbref[vref]{picKollKreis02} provides a simple approach to solving this problem.

The value~$d$ represents the distance in pixels between the center of the circle $(x_1, y_1)$ and the point $(x_2, y_2)$. If~$d \leq r$, the point lies inside the circle or touches it. However, we do not actually need the distance itself. Put simply, we only need to know whether the expression on the left side of the inequality is smaller than the one on the right side. We can therefore avoid the expensive square root operation and instead check $(x_2 - x_1)^2 + (y_2 - y_1)^2 \leq r^2$. We therefore extend \texttt{Bubble} with an appropriate method.

\begin{figure}[H]
\begin{center}\index{Pythagoras, Satz von}
\tikzset{
    shape kreis/.style= {
    draw,
    fill = yellow!30,
    line width = 1pt,
    inner xsep = 0.0cm,
    inner ysep = 0.0cm,
   }
}

\begin{tikzpicture}
\draw [->, name=xachse] (0cm, 6cm)  -- +(13cm, 0cm);
\draw [<-, name=yachse] (0cm, 0cm)  -- +(0cm, 6cm);

\draw (4.0cm, 2.5cm) node[name=k1,shape=circle,shape kreis,  minimum height = 4cm] {};
\draw (9.5cm, 4.0cm) node[name=k2,shape=circle,shape kreis,  minimum height = 0.1cm] {};

\draw[-, very thick, blue] 
 (k1.north west) --  node[below, blue, xshift=0cm] {$r$} (k1.center);

\draw[-, very thick, blue] 
 (k1.center) --  node[below, blue, sloped, xshift=0cm] {\footnotesize$d=\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$} (k2.center);

\draw[-, very thick, red, dotted] 
 (k1.center) --  +(0cm, +3.5cm);
\draw[-, very thick, red, dotted] 
 (k1.center) --  +(-4.0cm, 0cm);

\draw[-, very thick, red, dotted] 
 (k2.center) --  +(0cm, +2.0cm);
\draw[-, very thick, red, dotted] 
 (k2.center) --  +(-9.5cm, 0cm);

\path [name=x1, color=red] let \p1 = (k1) in node  at (\x1,+6.4cm) {$x_1$};
\path [name=x2, color=red] let \p1 = (k2) in node  at (\x1,+6.4cm) {$x_2$};
\path [name=y1, color=red] let \p1 = (k1) in node  at (-0.4cm,\y1) {$y_1$};
\path [name=y2, color=red] let \p1 = (k2) in node  at (-0.4cm,\y1) {$y_2$};
\end{tikzpicture}
\caption[collision detection -- point inside a circle?]{collision detection -- point inside a circle (\gls{pythagoras})?}\label{picKollKreis02}
\end{center}
\end{figure}

\lstsource{SRC/02 Examples/02 Bubbles/v05/bubbles.py}{117}{122}{python}{Bubbles (\reqref{reqMauscursor}) -- \texttt{Game.collidepoint()}}{srcbubbles05a}  

With the help of this method, the solution is no longer a problem. The variable \texttt{is\_over} is a flag that keeps track of whether the mouse coordinates are inside a bubble or not. The normal case is that the mouse is not inside any bubble, so the variable is initialized with \false.

After that, the current mouse position is obtained using \texttt{pygame.mouse.\-get\-\_pos()}\myindex{pyg}{\texttt{mouse}!\texttt{get\_pos()}}. This mouse position is passed to the \texttt{Bubble.collidepoint()} method in \zeiref{srcBubble0502}. If a bubble is found that collides with the mouse, the flag is set to \true\ and the loop is terminated using \texttt{break}. This saves some processing time, since not all remaining bubbles have to be checked. Depending on the flag, the mouse cursor is then set accordingly.\myindex{pyg}{\texttt{SYSTEM\_CURSOR\_HAND}}\myindex{pyg}{\texttt{SYSTEM\_CURSOR\_CROSSHAIR}}

\lstsource{SRC/02 Examples/02 Bubbles/v05/bubbles.py}{124}{134}{python}{Bubbles (\reqref{reqMauscursor}) -- \texttt{Game.set\_mousecursor()}}{srcbubbles05b}  

The \texttt{update()} method in \texttt{Game} still needs to be extended by adding the call to the collision check.

\lstsource{SRC/02 Examples/02 Bubbles/v05/bubbles.py}{99}{102}{python}{Bubbles (\reqref{reqMauscursor}) -- \texttt{update()} in \texttt{Game}}{srcbubbles05c}  

Try running the program. Place the mouse in a lower-left corner outside a bubble and wait until the growing bubble touches the mouse.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\Reqref{reqBlasenzerplatzen}: Bubbles burst}
\begin{diskbox}
	\url{https://github.com/adamsralf/pygame_book/tree/main/src/02%20Examples/02%20Bubbles/v06}
\end{diskbox}

\br{Bubbles burst}{reqBlasenzerplatzen}
	When a left mouse click occurs inside a bubble, the bubble should burst.
\er

Most of the work required to implement this requirement has already been done with the implementation of the \texttt{Bubble.collidepoint()} method. We only need to use this method in a clever way -- in fact, only a few remaining steps are necessary. In \texttt{watch\_for\_events()}, the left mouse click is detected first (\zeiref{srcBubble0601})\myindex{pyg}{\texttt{MOUSEBUTTONDOWN}}\myindex{pyg}{\texttt{mouse}!\texttt{get\_pos()}}\randnotiz{MOUSEBUTTONDOWN get\_pos()} and the current mouse position is passed to the newly created \texttt{sting()} method (\zeiref{srcBubble0602}).

\begin{hintbox}[\texttt{watch\_\-for\_\-events()} as a dispatcher]
	As a general rule, implement as little logic as possible in \texttt{watch\_\-for\_\-events()}. This method acts as a dispatcher; the actual processing should always be delegated to separate methods.
\end{hintbox}

\lstsource{SRC/02 Examples/02 Bubbles/v06/bubbles.py}{85}{94}{python}{Bubbles (\reqref{reqBlasenzerplatzen}) -- \texttt{Game.watch\_for\_event()}}{srcbubbles06a}  

The \texttt{sting()} method is now very simple. All \texttt{Bubble} objects are iterated over and checked to see whether the mouse position lies within their radius (\zeiref{srcBubble0603}). If the answer is \emph{yes}, the corresponding object is removed from the sprite group using \texttt{kill()}\myindex{pyg}{\texttt{sprite}!\texttt{Sprite}!\texttt{kill()}}\randnotiz{kill()}.

\lstsource{SRC/02 Examples/02 Bubbles/v06/bubbles.py}{138}{141}{python}{Bubbles (\reqref{reqBlasenzerplatzen}) -- \texttt{Game.sting()}}{srcbubbles06b}  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\Reqref{reqPunktestand}: Score}
\begin{diskbox}
	\url{https://github.com/adamsralf/pygame_book/tree/main/src/02%20Examples/02%20Bubbles/v07}
\end{diskbox}

\br{Score}{reqPunktestand}
\begin{enumerate}
	\item The game starts with 0~points.\label{reqPunktestandNull}
	\item When a bubble bursts, the score is increased proportionally to its radius.\label{reqPunktestandRadius}
	\item The score is displayed in the lower part of the screen.\label{reqPunktestandAnzeige}
\end{enumerate}
\er

Popping bubbles should, of course, be rewarded with points. To do this, the score has to be calculated and displayed. The simplest way to keep track of the score is to use a variable in \texttt{config.py} or a global variable. I prefer option~1 (see \srcref[vref]{srcbubbles07a}).

\lstsource{SRC/02 Examples/02 Bubbles/v07/config.py}{18}{18}{python}{Bubbles (\reqref{reqPunktestand}.\ref{reqPunktestandNull}) -- extension of \texttt{config.py}}{srcbubbles07a}  

Since popping a bubble no longer only makes it disappear but also updates the score, I added a new method to the \texttt{Bubble} class. In \zeiref{srcBubble0702}, the radius of the bubble is simply added to the score.

\lstsource{SRC/02 Examples/02 Bubbles/v07/bubbles.py}{74}{76}{python}{Bubbles (\reqref{reqPunktestand}.\ref{reqPunktestandRadius}) -- \texttt{Bubble.stung()}}{srcbubbles07b}  

The call to \texttt{stung()} is triggered by an adjusted \texttt{update()} method.

\lstsource{SRC/02 Examples/02 Bubbles/v07/bubbles.py}{55}{66}{python}{Bubbles (\reqref{reqPunktestand}.\ref{reqPunktestandRadius}) -- \texttt{Bubble.update()}}{srcbubbles07b1}  

The \texttt{sting()} and \texttt{update()} methods in \texttt{Game} have to be adjusted accordingly (see \zeiref{srcBubble0704} and \zeiref{srcBubble0705}).

\lstsource{SRC/02 Examples/02 Bubbles/v07/bubbles.py}{159}{162}{python}{Bubbles (\reqref{reqPunktestand}.\ref{reqPunktestandRadius}) -- \texttt{Game.sting()}}{srcbubbles07c}  

\lstsource{SRC/02 Examples/02 Bubbles/v07/bubbles.py}{122}{125}{python}{Bubbles (\reqref{reqPunktestand}.\ref{reqPunktestandRadius}) -- \texttt{Game.update()}}{srcbubbles07d}  

This leaves \reqref{reqPunktestand}.\ref{reqPunktestandAnzeige}. Similar to the playing area, I want to define the dimensions of the lower section as an output box in \texttt{config.py}.\randnotiz{Rect}\myindex{pyg}{\texttt{Rect}}

\lstsource{SRC/02 Examples/02 Bubbles/v07/bubbles.py}{19}{19}{python}{Bubbles (\reqref{reqPunktestand}.\ref{reqPunktestandAnzeige}) -- extension of \texttt{config.py}}{srcbubbles07e}  

For displaying the score itself, I once again create a small class that encapsulates this task: \texttt{Points}. In the constructor, a \texttt{Font}\myindex{pyg}{\texttt{font}!\texttt{Font}}\randnotiz{Font} object is created, which is then used in \texttt{update()} to render the score. The position of the text output is determined from the values defined in \texttt{config.py}. The rest is handled for me by the \texttt{Sprite} class.

\lstsource{SRC/02 Examples/02 Bubbles/v07/bubbles.py}{79}{90}{python}{Bubbles (\reqref{reqPunktestand}.\ref{reqPunktestandAnzeige}) -- Class \texttt{Points}}{srcbubbles07f}  

A few extensions remain in \texttt{Game}. In the constructor, the \texttt{Points} object is added to the \texttt{Group} object\myindex{pyg}{\texttt{sprite}!\texttt{Group}}.

\lstsource{SRC/02 Examples/02 Bubbles/v07/bubbles.py}{102}{104}{python}{Bubbles (\reqref{reqPunktestand}.\ref{reqPunktestandAnzeige}) -- extension of the \texttt{Game} constructor}{srcbubbles07g}  

\myebild{aquarium04}{0.30}{Bubbles -- score display}{picAquarium04}

In \abbref[vref]{picAquarium04}, you can see the score display in the lower part of the screen. This area could later also be used for a list of the top ten scores or other types of output.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\Reqref{reqSpielende}: Game over}
\begin{diskbox}
	\url{https://github.com/adamsralf/pygame_book/tree/main/src/02%20Examples/02%20Bubbles/v08}
\end{diskbox}

\br{Game over}{reqSpielende}
\begin{enumerate}
	\item If two bubbles touch, the game is lost.\label{reqSpielendeBlase}
	\item If a bubble touches the edge, the game is lost.\label{reqSpielendeRand}
\end{enumerate}
\er

Note: To make the game playable, I set the growth speed of a bubble to 10.

\lstsource{SRC/02 Examples/02 Bubbles/v08/bubbles.py}{53}{53}{python}{Bubbles (\reqref{reqSpielende}) -- \texttt{Bubble.speed}}{srcbubbles08x}  

The basic structure of our game makes it fairly easy to implement this requirement by extending the \texttt{update()} method in \texttt{Game}.

\lstsource{SRC/02 Examples/02 Bubbles/v08/bubbles.py}{125}{131}{python}{Bubbles (\reqref{reqSpielende}) -- extension of \texttt{Game.update()}}{srcbubbles08a}

In the new method \texttt{check\_\-bubble\-coll\-ision()}, it is checked whether bubbles touch each other or whether a bubble collides with the edge. This method is simply used as a decision maker (\zeiref{srcBubble0801}) to determine whether the game should end. If the answer is \emph{yes}, the flag of the main game loop is set; if the answer is \emph{no}, the remaining game logic is executed as usual. The two nested \forSchleife s starting at \zeiref{srcBubble0802} iterate over the bubble group twice and avoid two problems:\myindex{pyg}{\texttt{sprite}!\texttt{Group}!\texttt{sprites()}}\randnotiz{sprites()}

\begin{itemize}
	\item A bubble must not be compared with itself. Therefore, the index of the inner loop always starts one position after the current index of the outer loop, and the outer loop index ends before the last element of the bubble group.
	
	\item If bubble~1 has already been compared with bubble~2, bubble~2 should not be compared again with bubble~1. This is also achieved by the shifted index.
\end{itemize}

\myezweihbild{aquarium05}{0.65}{Bubbles -- collision with the edge}{picAquarium05}{aquarium06}{0.70}{Bubbles -- bubble collision}{picAquarium06}


In \zeiref{srcBubble0803}, \reqref{reqSpielende}.\ref{reqSpielendeBlase} is checked. For this purpose, circle-based collision detection using \texttt{collide\_circle()} is applied. In \zeiref{srcBubble0804} and \zeiref{srcBubble0805}, \reqref{reqSpielende}.\ref{reqSpielendeRand} is implemented. This makes use of the fact that the playing area is a rectangle and that the sprite itself also has a rectangular shape. The method \texttt{pygame.rect.Rect.\-con\-tains()}\myindex{pyg}{\texttt{rect}!\texttt{Rect}!\texttt{contains()}}\randnotiz{contains()} checks whether one rectangle is completely contained within another. If this is not the case -- meaning the bubble leaves the playing area -- a collision is detected.

\lstsource{SRC/02 Examples/02 Bubbles/v08/bubbles.py}{170}{182}{python}{Bubbles (\reqref{reqSpielende}) -- \texttt{Game.check\_bubblecollision()}}{srcbubbles08b}  

In \abbref[vref]{picAquarium05}, the collision of a bubble with the edge is shown. To make this easier to see, helper lines have been drawn. You can clearly see that the rectangle of the bubble is no longer contained within the rectangle of the playing area. \abbref[vref]{picAquarium06} shows the collision of two bubbles. Here as well, helper lines are drawn. These helper lines are displayed when you remove the three comment characters in \texttt{Game.draw()}.

\lstsource{SRC/02 Examples/02 Bubbles/v08/bubbles.py}{117}{123}{python}{Bubbles (\reqref{reqSpielende}) -- helper lines in \texttt{Game}}{srcbubbles08c}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\Reqref{reqZeitanpassungen}: Time-based adjustments}
\begin{diskbox}
	\url{https://github.com/adamsralf/pygame_book/tree/main/src/02%20Examples/02%20Bubbles/v09}
\end{diskbox}

\br{Time-based adjustments}{reqZeitanpassungen}
	The bubbles should grow faster over time.
\er

Since the bubbles are supposed to grow faster over time, I want to pass the growth speed to them as a constructor parameter. In \zeiref{srcBubble0900}, this parameter is stored in an attribute.

\lstsource{SRC/02 Examples/02 Bubbles/v09/bubbles.py}{46}{54}{python}{Bubbles (\reqref{reqZeitanpassungen}) -- \texttt{Bubble}}{srcBubbles09a}  

These are all the required changes in \texttt{Bubble}; everything else happens in \texttt{Game}. In \zeiref{srcBubble0901}, a timer\randnotiz{Timer}\index{Timer} is created that emits a signal every \SI{1000}{ms}. Below that, the initial growth speed of the bubbles is set to \SI{10}{px}.

\lstsource{SRC/02 Examples/02 Bubbles/v09/bubbles.py}{101}{105}{python}{Bubbles (\reqref{reqZeitanpassungen}) -- adjustment of the \texttt{Game} constructor}{srcBubbles09b}

In \texttt{spawn\_bubble()}, the timer is checked and, if necessary, the bubble growth speed is increased (\zeiref{srcBubble0902}). The maximum growth speed is limited to~\SI{100}{px/s}; anything faster does not seem playable to me. Each timer signal increases the speed by~\SI{5}{px/s}. This is done in this method so that the new speed is available for newly created bubbles.

\lstsource{SRC/02 Examples/02 Bubbles/v09/bubbles.py}{133}{147}{python}{Bubbles (\reqref{reqZeitanpassungen}) -- \texttt{Game.spawn\_bubble()}}{srcBubbles09c}  

If you now try out the game, you will notice an easy start and a moderate increase in game difficulty.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\Reqref{reqKollisionanzeigen}: Display collision}
\begin{diskbox}
	\url{https://github.com/adamsralf/pygame_book/tree/main/src/02%20Examples/02%20Bubbles/v10}
\end{diskbox}

\br{Display collision}{reqKollisionanzeigen}
	If bubbles collide with the edge or with each other, they should change color and remain visible for~\SI{5}{s} before the application terminates.
\er

\begin{wrapfigure}[6]{r}{3.5cm}%
	\begin{center}%
		\vspace{-1cm}%
		\myfigure{blase2.png}{0.05}{Bubble~2}{picBlase2}%
	\end{center}%
\end{wrapfigure}%
So far, the game ends so quickly that I cannot really check whether I actually lost for a valid reason or whether the program is misbehaving. With this requirement, I want to be able to see the two colliding bubbles, or the bubble that touches the edge, in a different color. For this purpose, I colored the bubble red (see \abbref{picBlase2}).


To achieve this, a second \texttt{BubbleContainer} with scaled red bubbles is required. To make access easier, these containers are stored in \texttt{Game} as a static dictionary.

In \zeiref{srcBubble1001}, such a dictionary is created. Under a key, I can now store arbitrary \texttt{BubbleContainer} objects.
 
\lstsource{SRC/02 Examples/02 Bubbles/v10/bubbles.py}{101}{102}{python}{Bubbles (\reqref{reqKollisionanzeigen}) -- extension of \texttt{Game}}{srcbubbles10a}

The constructor of \texttt{BubbleContainer} now receives a filename as a parameter, allowing different graphics to be used as a basis.

\lstsource{SRC/02 Examples/02 Bubbles/v10/bubbles.py}{34}{38}{python}{Bubbles (\reqref{reqKollisionanzeigen}) -- change to the constructor of \texttt{BubbleContainer}}{srcbubbles10b}

The constructor of \texttt{Game} now populates the static dictionary \texttt{BUBBLE\_CONTAINER} (\zeiref{srcBubble1003} and \zeiref{srcBubble1004}).

\newpage
\lstsource{SRC/02 Examples/02 Bubbles/v10/bubbles.py}{108}{111}{python}{Bubbles (\reqref{reqKollisionanzeigen}) -- change to the constructor of \texttt{Game}}{srcbubbles10c}

Several changes are now required in \texttt{Bubble}. The new attribute \texttt{mode} (\zeiref{srcBubble1005}) determines the color of the bubble. Whenever an image is loaded from the \texttt{Bubble\-Con\-tainer}, this attribute controls which of the two \texttt{Bubble\-Con\-tainer} instances is used as the data source. As an example, \zeiref{srcBubble1006} in \texttt{update()} can be mentioned here.

\lstsource{SRC/02 Examples/02 Bubbles/v10/bubbles.py}{46}{69}{python}{Bubbles (\reqref{reqKollisionanzeigen}) -- constructor of \texttt{Bubble} and \texttt{update()}}{srcbubbles10d}

If the mode changes, the alternative color has to be reloaded. This is handled by the \texttt{set\_mode()} method in \texttt{Bubble}.

\lstsource{SRC/02 Examples/02 Bubbles/v10/bubbles.py}{71}{74}{python}{Bubbles (\reqref{reqKollisionanzeigen}) -- \texttt{Bubble.set\_mode()}}{srcbubbles10e}  

\newpage
\begin{wrapfigure}[15]{l}{11.0cm}%
	\begin{center}%
		\vspace{-1.0em}%
		\myfigure{aquarium07.png}{0.35}{Bubbles -- displaying a collision}{picAquarium07}%
	\end{center}%
\end{wrapfigure}%
Now, in the case of a collision -- that is, when the game ends -- the mode simply needs to be changed.

In \abbref[vref]{picAquarium07}, you can see how the two colliding bubbles appear in red. An example of how this is implemented can be found in \zeiref{srcBubble1008}. In a nested \forSchleife, all sprites are iterated over.

A naive approach would cause problems if both loops compared all sprites from start to finish. First, because due to symmetry you would check $B=A$ even though you have already checked $A=B$. Second, because you would end up comparing each sprite with itself, which would lead to a false collision detection.

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}[
			font=\small,
			cell/.style={draw, minimum width=7mm, minimum height=7mm, align=center},
			idx/.style={font=\scriptsize},
			ok/.style={fill=green!12},
			skip/.style={fill=gray!15},
			self/.style={fill=red!12},
			arrow/.style={-Latex, thick},
			note/.style={align=left, text width=6.2cm}
			]
			
			% --- Parameters (visual only): we illustrate N=6 bubbles (indices 0..5)
			\def\N{6}
			
			% --- Grid origin
			\coordinate (O) at (0,-1.2);
			
			% --- Axis labels
			\node[idx, anchor=east] at ($(O)+(0,0)$) {};
			\node[idx, anchor=south] at ($(O)+(0,0)$) {};
			
			\node[idx, anchor=south]           at ($(O)+(2.60cm,   0.50cm)$) {inner index \texttt{$index_2$} $\rightarrow$};
			\node[idx, anchor=east, rotate=90] at ($(O)+(-0.50cm, -0.90cm)$) {$\leftarrow$ outer index \texttt{$index_1$}};
			
			% --- Draw header row/col indices
			\foreach \j in {0,...,5} {
				\node[idx, anchor=south] at ($(O)+(0.9cm+0.7cm*\j, -0.2cm)$) {\j};
				\node[idx, anchor=east]  at ($(O)+(0.55cm,         -0.7cm*\j-0.6cm)$) {\j};
			}
			
			% --- Draw cells: rows=i (index1), cols=j (index2)
			% Convention:
			%  - diagonal (i=j): self comparison -> forbidden
			%  - below diagonal (j<i): duplicates (would compare (2,1) after (1,2)) -> skipped
			%  - above diagonal (j>i): valid comparisons -> executed
			\foreach \i in {0,...,5} {
				\foreach \j in {0,...,5} {
					\pgfmathtruncatemacro{\x}{\j}
					\pgfmathtruncatemacro{\y}{\i}
					\coordinate (C\i\j) at ($(O)+(0.9cm+0.7cm*\j, -0.7cm*\i-0.6cm)$);
					
					\ifnum\j=\i
					\node[cell,self] at (C\i\j) {$\times$};
					\else
					\ifnum\j<\i
					\node[cell,skip] at (C\i\j) {};
					\else
					\node[cell,ok] at (C\i\j) {$\large \bullet$};
					\fi
					\fi
				}
			}
			
			% --- Legend
			\node[draw, rounded corners, inner sep=6pt, anchor=west] (legend) at ($(O)+(5.2cm, -2.5cm)$) {
				\begin{tabular}{@{}l@{\;\;}l@{}}
					\tikz\draw[fill=green!12,draw] (0,0) rectangle (0.25,0.25); & executed ($j>i$)\\
					\tikz\draw[fill=red!12,draw]   (0,0) rectangle (0.25,0.25); & illegal self-check ($j=i$)\\
					\tikz\draw[fill=gray!15,draw]  (0,0) rectangle (0.25,0.25); & duplicate pair ($j<i$)\\
				\end{tabular}
			};
		\end{tikzpicture}
		\caption{Why does the inner loop start at \texttt{$index_1+1$}?}\label{picForFor01}
	\end{center}
\end{figure}

In \abbref[vref]{picForFor01}, the algorithm used is illustrated. For each outer index \texttt{i=$index_1$}, the inner loop runs \texttt{j=$index_2$} from $i+1$ to $N-1$: \texttt{for $index_2$ in range($index_1+1$, N)}

\begin{itemize}
	\item Starting at $i+1$ skips the diagonal ($j=i$), so a bubble is never compared with itself.
	\item It also skips everything left of the diagonal ($j<i$), which would repeat comparisons
	(e.g.\ $(1,2)$ and later $(2,1)$).
	\item The outer loop stops at $N-2$ (i.e.\ \texttt{range(0, N-1)}), because when $i=N-1$
	there is no valid $j>i$ left to compare.
\end{itemize}


After that, it is checked whether both sprites are of type \texttt{Bubble}. Only then is a collision check performed — before that, it would not be worthwhile. If a collision is detected, both bubbles are colored red and the function is exited.

But what if the two bubbles do not touch each other? In that case, there is no need to check whether either of them touches the edge. If one of them does, that bubble is also colored red and the function is exited.


\lstsource{SRC/02 Examples/02 Bubbles/v10/bubbles.py}{183}{199}{python}{Bubbles (\reqref{reqKollisionanzeigen}) -- \texttt{Game.check\_bubblecollision()}}{srcbubbles10f}  

To give me enough time to see the collision, I want to wait for~\SI{2}{s} at the end. The method \texttt{pygame.time.wait()}\myindex{pyg}{\texttt{time}!\texttt{wait()}}\randnotiz{wait()} pauses the application for the specified duration (\zeiref{srcBubble1007}).

\lstsource{SRC/02 Examples/02 Bubbles/v10/bubbles.py}{201}{213}{python}{Bubbles (\reqref{reqKollisionanzeigen}) -- waiting time in \texttt{run()}}{srcbubbles10g}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\subsection{\Reqref{reqPause}: Pause}
\begin{diskbox}
	\url{https://github.com/adamsralf/pygame_book/tree/main/src/02%20Examples/02%20Bubbles/v11}
\end{diskbox}

\br{Pause}{reqPause}
	The game enters or leaves pause mode by pressing the right mouse button or \keys{p}. The current game state is frozen and displayed in a \emph{grayed-out} form.
\er

The idea behind this requirement is that a necessary interruption should not automatically mean that the player loses the game. In \abbref[vref]{picAquarium08}, you can see what the pause screen should look like.

\myebild{aquarium08}{0.30}{Bubbles -- pause screen}{picAquarium08}

In the constructor of \texttt{Game}, the flag \texttt{pausing} is defined. It later controls whether the game is currently in pause mode or not.

\newpage
\lstsource{SRC/02 Examples/02 Bubbles/v11/bubbles.py}{125}{125}{python}{Bubbles (\reqref{reqPause}) -- constructor in \texttt{Game}}{srcbubbles11b}

In \texttt{watch\_for\_events()}, it is now checked whether the \texttt{P} key (\zeiref{srcBubble1103}) or the right mouse button (\zeiref{srcBubble1104}) has been pressed. In both cases, the new \texttt{setpause()} method is called.

\lstsource{SRC/02 Examples/02 Bubbles/v11/bubbles.py}{128}{141}{python}{Bubbles (\reqref{reqPause}) -- \texttt{Game.watch\_for\_events()}}{srcbubbles11c}  

Für die Darstellung der Pause, habe ich die -- vielleicht etwas überflüssige -- Klasse \texttt{Pause} implementiert. 

\lstsource{SRC/02 Examples/02 Bubbles/v11/bubbles.py}{45}{50}{python}{Bubbles (\reqref{reqPause}) -- Class \texttt{Pause}}{srcbubbles11d}  

In the constructor of \texttt{Game}, an object of the \texttt{Pause} class is created so that it can be used in \texttt{draw()}.

\lstsource{SRC/02 Examples/02 Bubbles/v11/bubbles.py}{126}{126}{python}{Bubbles (\reqref{reqPause}) -- constructor in \texttt{Game}}{srcbubbles11g}

However, the \texttt{setpause()} method still needs to be explained. This method either adds the \texttt{Pause} object to the list of sprites or removes it again, depending on whether the game is currently in pause mode or not. Afterwards, the boolean value of the flag is negated (\gls{toggling}).

\lstsource{SRC/02 Examples/02 Bubbles/v11/bubbles.py}{157}{162}{python}{Bubbles (\reqref{reqPause}) -- \texttt{Game.setpause()}}{srcbubbles11h}  

Nothing more is required, since the rest is handled by the usual \texttt{update()} and \texttt{draw()} mechanisms.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\Reqref{reqNeustart}: Restart}
\begin{diskbox}
	\url{https://github.com/adamsralf/pygame_book/tree/main/src/02%20Examples/02%20Bubbles/v12}
\end{diskbox}

\br{Restart}{reqNeustart}
	At the end of the game, the player should be asked whether they want to restart the game or not.
\er

The basic idea of the implementation is to define the state of the game using two flags\index{flag}\randnotiz{flag}. As with the pause feature, we need a flag that controls whether the semi-transparent foreground is placed over the game (\texttt{restarting}). This is always the case when the bubble collision check detects a collision.

The other flag -- \texttt{do\_start} -- indicates whether the player wants to restart. At the relevant points in \texttt{update()} and \texttt{draw()}, these flags are then evaluated.

The task of displaying a confirmation dialog in the foreground is essentially already solved by the \texttt{Pause} class. I can therefore generalize this class by renaming it to \texttt{Message} and passing the filename to the constructor as a string parameter (\zeiref{srcBubble1202}).

\lstsource{SRC/02 Examples/02 Bubbles/v12/bubbles.py}{45}{50}{python}{Bubbles (\reqref{reqNeustart}) -- from \texttt{Pause} to \texttt{Message}}{srcbubbles12b}

\myebild{aquarium09}{0.3}{Bubbles -- restart screen}{picAquarium09}

In \texttt{Game}, starting at \zeiref{srcBubble1203}, the adjustments required for restarting the game are implemented in the constructor. Essentially, two \texttt{Message} objects are created for pause and restart, and all attributes that need to be reset on a start or restart are handled in the new \texttt{restart()} method.


\lstsource{SRC/02 Examples/02 Bubbles/v12/bubbles.py}{121}{124}{python}{Bubbles (\reqref{reqNeustart}) -- restructuring of the \texttt{Game} constructor}{srcbubbles12c}

The score is reset, the sprite group containing the bubbles is cleared, the timers are reinitialized, the bubble growth speed is reset to its initial value, and the two flags described above are set to \false.

\lstsource{SRC/02 Examples/02 Bubbles/v12/bubbles.py}{163}{171}{python}{Bubbles (\reqref{reqNeustart}) -- \texttt{Game.restart()}}{srcbubbles12d}

The method is called in \texttt{update()} when the corresponding flag \texttt{do\_start} is set. In addition, \texttt{update()} inserts the restart screen into the sprite group and sets the flag \texttt{restarting} to \true\ when a collision is detected.

\newpage
\lstsource{SRC/02 Examples/02 Bubbles/v12/bubbles.py}{150}{161}{python}{Bubbles (\reqref{reqNeustart}) -- \texttt{Game.update()}}{srcbubbles12e}  

The response to the restart screen is queried in \texttt{watch\_for\_events()} and translated into the corresponding flag values. If the player responds with~\keys{y} (\zeiref{srcBubble1205}), the game has to be restarted, so \texttt{do\_start} is set to \true. If the player presses~\emph{N}, the game should end, which is why the flag of the main game loop is set to \false\ (\zeiref{srcBubble1206}).

\lstsource{SRC/02 Examples/02 Bubbles/v12/bubbles.py}{135}{138}{python}{Bubbles (\reqref{reqNeustart}) -- extension of \texttt{watch\_for\_events()}}{srcbubbles12f}
  
Since we now display a semi-transparent foreground at the end of the game, there is no longer any need for a two-second pause to inspect the colliding bubbles (see \abbref[vref]{picAquarium09}).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{\Reqref{reqSound}: Sound}
\begin{diskbox}
	\url{https://github.com/adamsralf/pygame_book/tree/main/src/02%20Examples/02%20Bubbles/v13}
\end{diskbox}

\br{Sound}{reqSound}
\begin{enumerate}
	\item The appearance of bubbles is accompanied by a sound.\label{reqSoundErscheinen}
	\item Popping a bubble is accompanied by a sound.\label{reqSoundZerstechen}
	\item Touching a bubble is accompanied by a sound.\label{reqSoundBerühren}
\end{enumerate}
\er

Finally, a small sound accompaniment is added. Similar to the bubble sprites, I do not want to lose performance by repeatedly loading sound files. Therefore, the sounds are stored in a static dictionary (\zeiref{srcBubble1301}).

\lstsource{SRC/02 Examples/02 Bubbles/v13/bubbles.py}{109}{111}{python}{Bubbles (\reqref{reqSound}) -- \texttt{SOUND\_CONTAINER}}{srcbubbles13a}  

In the constructor of \texttt{Game}, the dictionary is populated with objects of the \texttt{Sound} class. The class used for sound effects is \texttt{pygame.mixer.Sound}\myindex{pyg}{\texttt{mixer}!\texttt{Sound}}\randnotiz{Sound} (see \zeiref{srcBubble1302} ff.).

\lstsource{SRC/02 Examples/02 Bubbles/v13/bubbles.py}{113}{122}{python}{Bubbles (\reqref{reqSound}) -- populating \texttt{SOUND\_CONTAINER}}{srcbubbles13b}

Now the sounds only need to be played at the appropriate places using \texttt{pygame.mixer\-.Sound\-.play()}\myindex{pyg}{\texttt{mixer}!\texttt{Sound}!\texttt{play()}}\randnotiz{play()}. First, the sound that is played when a new bubble appears: in \texttt{spawn\_\-bubb\-le()} in \zeiref{srcBubble1303}.

\lstsource{SRC/02 Examples/02 Bubbles/v13/bubbles.py}{198}{201}{python}{Bubbles  (\reqref{reqSound}.\ref{reqSoundErscheinen}) -- \texttt{spawn\_bubble()}}{srcbubbles13c}

Then, when a bubble bursts in \texttt{sting()} (\zeiref{srcBubble1304}):

\lstsource{SRC/02 Examples/02 Bubbles/v13/bubbles.py}{222}{226}{python}{Bubbles (\reqref{reqSound}.\ref{reqSoundZerstechen}) -- \texttt{sting()}}{srcbubbles13d}

Finally, the sound is played when a collision with other bubbles or with the edge occurs in \texttt{update()}. Here, it must also be taken into account whether the game is currently displaying the restart prompt. If the answer is \emph{yes}, the sound must not be played again; otherwise, the touch sound would be played continuously.

\lstsource{SRC/02 Examples/02 Bubbles/v13/bubbles.py}{155}{167}{python}{Bubbles (\reqref{reqSound}.\ref{reqSoundBerühren}) -- \texttt{update()}}{srcbubbles13e}  

And that’s it :-)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Or maybe not?}
\begin{diskbox}
	\url{https://github.com/adamsralf/pygame_book/tree/main/src/02%20Examples/02%20Bubbles/v14}
\end{diskbox}

Pause, restart, and game over are currently still implemented rather sloppily; for example, the end of the game is delayed by playing a sound instead of using a properly programmed delay. In one version (see \srcref[vref]{srcbubbles10g}), I even froze the entire program for several seconds using \texttt{pygame.time.wait()}\myindex{pyg}{\texttt{time}!\texttt{wait()}} -- brrr :-(

It is far more advantageous to control the game using states. What exactly this means should become clear when looking at the solution.

As a first step, let us think about which states the game can actually have:

\begin{itemize}
	\item \texttt{PLAYING}: I am happily popping bubbles and collecting points.
	\item \texttt{PAUSED}: \keys{p} has been pressed and the game should stop temporarily, but not terminate.
	\item \texttt{WAITING}: The game has ended, but remains active for a few more seconds, for example to display a farewell message.
	\item \texttt{GAME\_OVER}: The game is exited. In our example, little or nothing happens here, but one might still want to close files or \glspl{socket}.
\end{itemize}

Let us simply add an enumeration for this:

\lstsource{SRC/02 Examples/02 Bubbles/v14/bubbles.py}{11}{15}{python}{Bubbles game state -- \texttt{GameState(Enum)}}{srcBubbles14a}  

Since we now have to manage more than just a single state indicating whether the game is paused or not, the attribute \texttt{self.state} is created in the constructor of \texttt{Game}. In addition, two attributes are introduced that will later be used to measure whether the game remains in a waiting state for \SI{10}{s} before it finally terminates.

\lstsource{SRC/02 Examples/02 Bubbles/v14/bubbles.py}{134}{138}{python}{Bubbles game state -- Constructor of \texttt{Game}}{srcBubbles14b}  

A real refactoring is now required for \texttt{watch\_for\_events()}. It no longer only checks for events, but also takes into account the current state of the game.

Consider pressing \keys{p} as an example: if the game state is currently \texttt{PLAYING}, the game switches to pause mode by calling \texttt{set\_pause()}. If the game is in the \texttt{PAUSED} state, calling \texttt{resume()} switches the game back to running mode.

\lstsource{SRC/02 Examples/02 Bubbles/v14/bubbles.py}{142}{167}{python}{Bubbles game state -- \texttt{Game.watch\_for\_events()}}{srcBubbles14c}  

Let us now take a closer look at the three helper methods, each of which is tailored to a specific state: \texttt{set\_pause()}, \texttt{set\_resume()}, and \texttt{set\_game\_over()}. All three methods consist of two parts: in the first part, the state change itself is performed, and in the second part, an action required by this state change is executed. In some cases, a message screen is added to the sprite group; in others, it is removed again. In the third method, the time at which the \SI{10}{seconds} waiting period begins is stored in \texttt{wait\_start\_time}.

\lstsource{SRC/02 Examples/02 Bubbles/v14/bubbles.py}{201}{211}{python}{Bubbles game state -- \texttt{set\_pause()}, \texttt{set\_resume()}, and \texttt{set\_game\_over()} of \texttt{Game}}{srcBubbles14d}  

Just as the game states are taken into account in \texttt{watch\_for\_events()}, they must also be considered in \texttt{update()}.

\lstsource{SRC/02 Examples/02 Bubbles/v14/bubbles.py}{174}{189}{python}{Bubbles game state -- \texttt{Game.update()}}{srcBubbles14e}  

What remains is the helper method that checks whether the \SI{10}{seconds} have elapsed: \texttt{check\_waiting\_timeout()}. In this method, the elapsed time is compared with \texttt{wait\_du\-ra\-tion}. If the time has elapsed, the game state is set to \texttt{GAME\_OVER}, so that the game can terminate cleanly.

\lstsource{SRC/02 Examples/02 Bubbles/v14/bubbles.py}{274}{279}{python}{Bubbles game state -- \texttt{Game.check\_waiting\_timeout()}}{srcBubbles14f}  

In \abbref[vref]{picBubbleState}, we can once again visually trace these state transitions.

\begin{figure}[H]
	\begin{center}
	\begin{tikzpicture}[
		state/.style={
			rectangle,
			rounded corners=0.5cm,
			draw=arrowblack,
			fill=stateblue,
			minimum width=2cm,
			minimum height=1cm,
			text centered,
			font=\small\bfseries
		},
		initial/.style={
			circle,
			draw=arrowblack,
			fill=arrowblack,
			minimum size=0.3cm,
			inner sep=0pt
		},
		final/.style={
			circle,
			draw=arrowblack,
			fill=white,
			minimum size=0.6cm,
			inner sep=0pt,
			line width=2pt
		},
		finalinner/.style={
			circle,
			fill=arrowblack,
			minimum size=0.2cm,
			inner sep=0pt
		},
		arrow/.style={
			->,
			thick,
			font=\small
		},
		loopabove/.style={
			min distance=2.5cm,
			loop,
			arrow,
			above=0.8cm,
			looseness=7
		},
		loopbelow/.style={
			min distance=2.5cm,
			loop,
			arrow,
			below=-0.8cm,
			looseness=7
		},
		arrowabove/.style={
			min distance=2.5cm,
			arrow,
			above=1.0cm,
			out=20, 
			in=160
		},
		arrowbelow/.style={
			min distance=2.5cm,
			arrow,
			below=-1.0cm,
			out=-160, 
			in=-20
		},
		arrowleft/.style={
			min distance=2.5cm,
			arrow,
			out=150, 
			in=-150
		},
		arrowright/.style={
			min distance=2.5cm,
			arrow,
			out=-30, 
			in=30
		}
		]
		
		% Startzustand
		\node[initial] (start) at (0, 0) {};
		
		% Zustände
		\node[state] (playing) at (5.0, 0) {PLAYING};
		\node[state] (paused) at (13.0, 0) {PAUSED};
		\node[state] (waiting) at (5.0, -4) {WAITING};
		\node[state] (gameover) at (5.0, -7) {GAME\_OVER};
		
		% Endzustand (Bullseye)
		\node[final] (end) at (5.0, -9) {};
		\node[finalinner] at (5.0, -9) {};
		
		% Übergänge
		% Start -> PLAYING
		\draw[arrow] (start) -- node[above, fill=white] {} (playing);
		
		% PLAYING <-> PAUSED
		\draw[arrowabove] (playing) to node[above, fill=white] {\keys{p} / right click} (paused);
		\draw[arrowbelow] (paused) to node[below, fill=white] {\keys{p} / right click} (playing);
		
		% PLAYING -> WAITING
		\draw[arrowright] (playing) to node[below right, fill=white] {collision} (waiting);
		
		% WAITING -> GAME_OVER
		\draw[arrow] (waiting) -- node[right, fill=white] {\keys{n}} (gameover);

		% WAITING -> PLAYING (Neustart)
		\draw[arrowleft] (waiting) to node[below left, fill=white] {\keys{j} / restart()} (playing);

		% GAME_OVER -> End
		\draw[arrow] (gameover) -- node[right, fill=white] {\SI{10}{sec}} (end);
		
		
		% Linksklick-Aktion im PLAYING-Zustand (Loop)
		\draw[loopabove] (playing) to node[above, fill=white] {left click / sting()} (playing);
		
	\end{tikzpicture}
		\caption{Bubbles -- state diagram}\label{picBubbleState}
\end{center}
\end{figure}
	


