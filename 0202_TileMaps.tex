% !TeX spellcheck = en_US
\newpage
\section{Tiles Are Beautiful}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{diskbox}
	\url{https://github.com/adamsralf/pygame_book/tree/main/src/01%20Techniques/02%20Tilemap}
\end{diskbox}
Very often, the visual appearance of games consists of many small and large tiles that are assembled in an appropriate way. These tiles are usually combined into larger bitmaps (\gls{spritelib}\index{Spritelib}\randnotiz{Spritelib}) and then have to be cut out correctly by the game developer. In \abbref[vref]{picTileMap01}, you can find such a simple sprite library.

I~will now show you how tiles can be cut out of a sprite library and used to assemble your own worlds. The required information is stored in a \Gls{csvdatei}. I~will also use several example levels (not to be confused with difficulty levels or floors within the game world) in order to address different types of sprites in different ways.

\begin{hintbox}[Hint]
	There is an excellent tool that helps you create such levels and integrate them into a game. It is called \Gls{tiled} and can be downloaded from \hyperlink{https://www.mapeditor.org/}{MapEditor}. Since there are already sufficiently detailed and high-quality introductions available for this software, I~will omit a description here.
	
\end{hintbox}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Our Example}

\myezweihbild{TileMap01.png}{0.40}{Sprite library (original)}{picTileMap01}{TileMap02.png}{0.40}{Sprite library (prepared)}{picTileMap02}

In \abbref{picTileMap01}, we can see such a sprite library. It contains tiles for building a landscape consisting of lakes, meadows, and forests, along with some \gls{gadget}\randnotiz{Gadget}. In \abbref{picTileMap02}, I~have made the individual tiles visible by adding a grid and numbering them. The numbers will become important again later. Our tiles have a width and a height of \SI{32}{px} each; they are arranged in \SI{16}{columns} and \SI{12}{rows}.

The goal is a game surface as shown in \abbref[vref]{picTileMap03}. The playing field -- coincidentally -- also has \SI{16}{columns} and \SI{12}{rows}.

\myebild{TileMap03.png}{0.50}{Example of tile based playground}{picTileMap03}

\subsection{A Green Meadow}

In the first step, I~will show how a single tile can be used to fill the entire game area. So let us get started. In \srcref{srcForest01}, we first find the usual suspects. The parameters \texttt{TILESIZE}, \texttt{TILEMAP\_NOF\_COLS}, \texttt{TILEMAP\_NOF\_ROWS}, and \texttt{TILEMAP\_WINDOW} should also be self-explanatory.

\lstsource{SRC/01 Techniques/02 Tilemap/config.py}{1}{14}{python}{Forest -- \texttt{config.py}}{srcForest01}

Also \texttt{Game} is very easy to understand.

\lstsource{SRC/01 Techniques/02 Tilemap/forest01.py}{78}{63}{python}{Forest -- \texttt{Game}}{srcForest02}

So far, everything happens inside the \texttt{WindowGame} class, which will of course change later on. In the constructor, the window is created with all its parameters and the sprite library is loaded. In \texttt{draw()}, a single tile is now cut out of the sprite library and stored in the variable \texttt{image}. The crucial part here is the parameters passed to \texttt{subsurface()}\myindex{pyg}{\texttt{surface}!\texttt{Surface}!\texttt{subsurface()}}\randnotiz{subsurface()}. Starting at position $(0,0)$ in the sprite library -- i.\,e.\ the top-left corner -- a rectangle of size $\SI{32}{px} \times \SI{32}{px}$ is cut out. This corresponds to the yellow-bordered rectangle~0 in \abbref[vref]{picTileMap02}.

Using the two \texttt{for} loops, this image is then distributed across the entire surface. In each loop iteration, the variable \texttt{position} is calculated from the row number \texttt{row} ($[0 - 12]$) and the column number \texttt{col} ($[0 - 16]$).  Multiplying the column number by the tile width yields the x-position, and multiplying the row number by the tile height yields the y-position at which the tile should be drawn.

The result then looks as shown in \abbref[vref]{picTileMap04}.

\newpage
\lstsource{SRC/01 Techniques/02 Tilemap/forest01.py}{7}{24}{python}{Forest -- \texttt{WindowGame}}{srcForest03}

However, I~would like to be able to select and display any arbitrary tile. For example, instead of a monotonous meadow, we might want it to be composed of the tiles with the numbers $0, 1, 2, 3, 4, 16, 17, 18, 19, 20, 32, 33, 34, 35, 36$. This practically calls for a separate class.

In the constructor (see \srcref[vref]{srcForest04}), only the bitmap of the sprite library is loaded. The method \texttt{sub\-sur\-face()} expects the tile number as a parameter.  The tiles are assumed to be numbered from left to right and from top to bottom. This makes it fairly easy to compute the column number and the row number from the tile number.

The column number is the value that remains after all complete rows have been removed. Example: The tile number is~34. I~want to determine the column number. All complete rows above tile~34 are irrelevant. Therefore, with 16~columns, from

\[34 \rightarrow 18 \rightarrow 2.\]

Mathematically, this is the remainder (\gls{modulo}) of an integer division. Do you remember? Elementary school? \emph{15 divided by 6 is 2 remainder 3}.  Or, in our case,
\[34 \bmod 16 = 2.\]

This is exactly what happens in \zeiref{srcforest0201}; the only difference is that the result is then multiplied by the number of pixels per column in order to obtain the left position of the tile.

The row number -- that is, the row in which tile~34 is located -- is determined in a similar, but slightly different way. In other words: how many complete rows -- i.\,e.\ 16 tiles -- are contained in the tile number? For this, we use integer division:
\[34 \div 16 = 2.\]

And since in computer science we always start counting at~0, the tile is indeed located in row~2. Take a look at \abbref[vref]{picTileMap02}! In \zeiref{srcforest0201}, the row number is then multiplied by the row height to obtain the top position of the tile.  The rest should be self-explanatory.

\lstsource{SRC/01 Techniques/02 Tilemap/forest02.py}{8}{16}{python}{Forest -- \texttt{Spritelib}}{srcForest04}

Now we integrate the new class into \texttt{WindowGame}. The constructor is extended by determining random tile numbers:

\lstsource{SRC/01 Techniques/02 Tilemap/forest02.py}{21}{31}{python}{Forest -- Extension of the Constructor of \texttt{WindowGame}}{srcForest05}

In \texttt{WindowGame.draw()}, we now only need to implement access to the tile number. The result then looks as shown in \abbref[vref]{picTileMap05}.

\lstsource{SRC/01 Techniques/02 Tilemap/forest02.py}{33}{41}{python}{Forest -- Selecting specific tile numbers in \texttt{Game.draw()}}{srcForest06}

\myezweihbild{TileMap04.png}{0.50}{Forest playground (1)}{picTileMap04}{TileMap05.png}{0.50}{Forest playground (2)}{picTileMap05}


So, what can we do already?
\begin{enumerate}
	\item We can provide a sprite library to all components of the game via a separate class.
	\item We can determine the row -- and thus the vertical pixel position in the sprite library -- from the tile number.
	\item We can determine the column -- and thus the horizontal pixel position in the sprite library -- from the tile number.
	\item We can compute the upper-left pixel position in the target window -- that is, the game playground -- from a row and column number.
\end{enumerate}

That is already quite a lot.

\subsection{Tile Numbers and Two-Dimensional Arrays}

In most cases, tiles should not be determined by a random generator. Instead, the tile numbers should be specified explicitly in some way. Two-dimensional arrays are well suited for this purpose, since they allow convenient access using row and column indices.

Nothing could be simpler, you might think. And the reader would be right ;-)

First, let us replace the random selection with a meaningful assignment using a two-dimensional array. The tile numbers are no longer random, but already correspond to those that we want to see later.

\lstsource{SRC/01 Techniques/02 Tilemap/forest03.py}{18}{39}{python}{Forest -- Tile numbers in a 2D array}{srcForest09}

The output is now simplified, as can be seen starting at \zeiref{srcforest0301}.

\lstsource{SRC/01 Techniques/02 Tilemap/forest03.py}{42}{50}{python}{Forest -- \texttt{WindowGame.draw()} using a 2D array}{srcForest10}

\begin{warningbox}[The result is a bit unsatisfying.]
\begin{itemize}
	\item Since there is only space for a single tile number at each tile position, background tiles are missing. As a result, an ugly black border becomes visible around these tiles.
	\item The semantic meaning of the tiles is completely lost. This may be acceptable for pure background tiles, but what if some tiles represent ground, others obstacles, and yet others gadgets with a special meaning?
\end{itemize}
\end{warningbox}
I~usually get by with these three semantic layers and encapsulate the whole concept in a \texttt{Map} class.

In the constructor, tile numbers are specified only for these three layers. For collision detection, the main program—or wherever it makes sense—can then always check whether a tile number is contained in \texttt{layer\_data[0]}, \texttt{layer\_data[1]}, or \texttt{layer\_data[2]}. The result with regard to the black backgrounds has also improved, as can be seen in \abbref[vref]{picTileMap07}; since I~can now first draw a green meadow as a background in level~0 and later place a tent or a tree in level~1 or~2.

\lstsource{SRC/01 Techniques/02 Tilemap/forest04.py}{19}{63}{python}{Forest -- \texttt{Map} with a 2D array}{srcForest11}

In \texttt{WindowGame}, the object of the class is now created:

\lstsource{SRC/01 Techniques/02 Tilemap/forest04.py}{73}{74}{python}{Forest -- \texttt{Map} object in \texttt{WindowGame}}{srcForest12}

In \texttt{draw()}, only the \texttt{Map} object is accessed from now on. Unassigned tiles (see \zeiref{srcforest0401}) are skipped in the process.

\lstsource{SRC/01 Techniques/02 Tilemap/forest04.py}{76}{87}{python}{Forest -- \texttt{WindowGame.draw()} using a \texttt{Map} object}{srcForest13}

\myezweihbild{TileMap06.png}{0.50}{Forest playground (3)}{picTileMap06}{TileMap07.png}{0.50}{Forest playground (4)}{picTileMap07}

\begin{warningbox}
	Hard-coding the tile numbers directly in the source code is, of course, a nightmare. 
\end{warningbox}

It is much better to store them in separate CSV files. The appeal of this approach is that it allows the use of external programs such as \emph{Tiled} for level design. Even self-made tools like \texttt{forest00.py} (which can be found in the GitHub repository of this script) are often sufficient and much more efficient than specifying the data directly in the source code.

So let us quickly switch to using CSV files. First, the \texttt{csv} module needs to be imported.

\lstsource{SRC/01 Techniques/02 Tilemap/forest05.py}{1}{1}{python}{Forest -- \texttt{csv} import}{srcForest14}

In the constructor, the CSV files located in the \texttt{level} subdirectory are now loaded. Please note that creating the \texttt{Map} object now requires specifying how many levels are available as CSV files.

\lstsource{SRC/01 Techniques/02 Tilemap/forest05.py}{20}{28}{python}{Forest -- Constructor of \texttt{Map} using \texttt{csv}}{srcForest15}

That should be sufficient at this point :-)










